{"version":3,"sources":["../lib/index.ts"],"names":["encodePath","path","split","map","encodeURIComponent","join","basename","replace","dirname","joinPaths","args","arguments","length","nonEmptyArgs","filter","arg","lastArg","leadingSlash","charAt","trailingSlash","sections","reduce","acc","section","concat","first","isSamePath","path1","path2","pathSections1","p","pathSections2","apply","undefined"],"mappings":"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","sourcesContent":["/**\n * URI-Encodes a file path but keep the path slashes.\n */\nexport function encodePath(path: string): string {\n    if (!path) {\n        return path\n    }\n\n    return path\n        .split('/')\n        .map(encodeURIComponent)\n        .join('/')\n}\n\n/**\n * Returns the base name of the given path.\n * For example for \"/abc/somefile.txt\" it will return \"somefile.txt\"\n */\nexport function basename(path: string): string {\n    return path\n        .replace(/\\\\/g, '/')\n        .replace(/.*\\//, '')\n}\n\n/**\n * Returns the dir name of the given path.\n * For example for \"/abc/somefile.txt\" it will return \"/abc\"\n */\nexport function dirname(path: string): string {\n    return path\n        .replace(/\\\\/g, '/')\n        .replace(/\\/[^\\/]*$/, '')\n}\n\n/**\n * Join path sections\n */\nexport function joinPaths(...args: string[]) {\n    if (arguments.length < 1) {\n        return ''\n    }\n\n    // discard empty arguments\n    const nonEmptyArgs = args.filter(arg => arg.length > 0)\n    if (nonEmptyArgs.length < 1) {\n        return ''\n    }\n\n    const lastArg = nonEmptyArgs[nonEmptyArgs.length - 1]\n    const leadingSlash = nonEmptyArgs[0].charAt(0) === '/'\n    const trailingSlash = lastArg.charAt(lastArg.length - 1) === '/';\n    const sections = nonEmptyArgs.reduce((acc, section) => acc.concat(section.split('/')), [] as string[])\n\n    let first = !leadingSlash\n    const path = sections.reduce((acc, section) => {\n        if (section === '') {\n            return acc\n        }\n\n        if (first) {\n            first = false\n            return acc + section\n        }\n\n        return acc + '/' + section\n    }, '')\n\n    if (trailingSlash) {\n        // add it back\n        return path + '/'\n    }\n    return path\n}\n\n/**\n * Returns whether the given paths are the same, without\n * leading, trailing or doubled slashes and also removing\n * the dot sections.\n */\nexport function isSamePath(path1: string, path2: string): boolean {\n    const pathSections1 = (path1 || '').split('/').filter(p => p !== '.')\n    const pathSections2 = (path2 || '').split('/').filter(p => p !== '.')\n    path1 = joinPaths.apply(undefined, pathSections1)\n    path2 = joinPaths.apply(undefined, pathSections2)\n\n    return path1 === path2\n}\n"],"file":"index.js"}